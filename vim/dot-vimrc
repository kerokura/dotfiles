" PLUGIN {{{

" vim-plug {{{

if has('win32')
    call plug#begin('~/vimfiles/plugged')
else
    call plug#begin('~/.vim/plugged')
endif

Plug 'kana/vim-textobj-user'      " kana's objs depend on it
Plug 'kana/vim-textobj-entire'    " ie
Plug 'kana/vim-textobj-indent'    " ii
Plug 'kana/vim-textobj-line'      " il
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'ap/vim-css-color'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'morhetz/gruvbox'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'tpope/vim-fugitive'
Plug 'vim-scripts/vim-auto-save'
Plug 'deton/jasentence.vim'
Plug 'vimwiki/vimwiki'
Plug 'suan/vim-instant-markdown', {'rtp': 'after'}
Plug 'junegunn/vim-peekaboo'
Plug 'ryanoasis/vim-devicons'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'

call plug#end()

" }}}

" Settings {{{

" EasyAlign {{{

xmap <Leader>a <Plug>(EasyAlign)
nmap <Leader>a <Plug>(EasyAlign)
nmap <Leader>= <Plug>(EasyAlign)ii*=<CR>
nmap <Leader>: <Plug>(EasyAlign)ii<RIGHT>:<CR>
nmap <Leader>t vip:s/\v\s\s+/<BAR>/g<CR>gv:s/^/<BAR><CR>gv:s/$/<BAR><CR><Plug>(EasyAlign)ii*<BAR>'<yyp:s/\v[^ <BAR>]/-/g<CR>:nohlsearch<CR>
nmap <Leader>T <Plug>(EasyAlign)ii*<Bar><CR>

" }}}
" Abolish {{{

nnoremap <Leader>/a :%Subvert/{}/{}/g<LEFT><LEFT><LEFT><LEFT><LEFT><LEFT>
nnoremap <silent> <Leader>n :Subvert/{true,false}/{false,true}/g<CR>:nohlsearch<CR>
vnoremap <silent> <Leader>n :Subvert/{true,false}/{false,true}/g<CR>:nohlsearch<CR>

" }}}
" Limelight {{{

let g:limelight_default_coefficient = 0.8
let g:limelight_conceal_ctermfg = 239
let g:limelight_conceal_guifg = '#504945'

nnoremap <Esc>L :Limelight!!<CR>

" }}}
" Goyo {{{

nnoremap <Esc>G :Goyo<CR>

" }}}
" vim-airline {{{

let g:airline_powerline_fonts = 0
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 0
let g:airline#extensions#tabline#show_splits = 0
let g:airline#extensions#tabline#tabs_label = ''
let g:airline#extensions#tabline#show_tab_count = 0
let g:airline#extensions#tabline#show_tab_nr = 0
let g:airline#extensions#whitespace#mixed_indent_algo = 1
let g:airline#extensions#ctrlp#color_template = 'visual'

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''

" }}}
" vim-auto-save {{{

let g:auto_save = 0                " enable AutoSave on Vim startup
let g:auto_save_in_insert_mode = 0 " do not save while in insert mode

" }}}
" vimwiki {{{

let g:vimwiki_list = [{'path': '~/vimwiki/vim', 'syntax': 'markdown', 'ext': '.md'}]
let g:vimwiki_ext2syntax = {'.md': 'markdown'}
let g:vimwiki_folding = 'expr'
let g:vimwiki_url_maxsave=0

" NOTE:
" comment out al/il lines in favor of textobj-line
" bundle/vimwiki/ftplugin/vimwiki.vim

" }}}
" instant-markdown {{{

let g:instant_markdown_autostart = 0
let g:instant_markdown_port = 8890

" }}}
" CtrlP {{{

let g:ctrlp_match_window = 'bottom,ttb,min:10,max:10,results:30'
let g:ctrlp_working_path_mode = 'rw'
let g:ctrlp_tabpage_position = 'al'
let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
let g:ctrlp_regexp = 1

nnoremap <Leader><C-P> :CtrlPCurWD<CR>

" }}}
" Misc {{{
 
runtime macros/matchit.vim

" }}}

" }}} 

" }}}

" VARIABLE {{{

let g:my_ftmode = 'default'
let g:ft_man_open_mode = 'tab'
let g:ft_man_folding_enable = 1

" }}}

" OPTION {{{

if has("syntax")
    syntax on
endif

" 4 spaces for indent
set expandtab
set tabstop=4
set softtabstop=4
set shiftwidth=4
set autoindent

" format options for multi-byte chars
set formatoptions+=B
set formatoptions+=j
augroup myft
    autocmd!
    autocmd FileType * setlocal formatoptions-=c formatoptions-=o formatoptions-=r
augroup END

" search
set hlsearch
set incsearch
set grepprg=ag\ --vimgrep\ $*
set grepformat=%f:%l:%c:%m

" soft wrapping
set wrap
set linebreak
set nolist  " list disables linebreak
set textwidth=0
set wrapmargin=0

" split
set diffopt+=vertical
set splitright
set splitbelow

" fold
set foldmethod=marker

" misc
set display=lastline " When not included, a last line that doesn't fit is replaced with "@" lines.
set history=1000
set complete+=k
set number
set relativenumber
set cursorline
set showcmd
set path+=**
set wildmenu
set wildmode=full
set clipboard=unnamedplus
set backspace=indent,eol,start
set nrformats=
set laststatus=2
set noswapfile

" }}}

" COLORS {{{

if !has('gui_running') && !has('win32')
    set term=screen
endif
set t_Co=256

colorscheme gruvbox
set background=dark
let g:gruvbox_bold      = 1
let g:gruvbox_italic    = 0
let g:gruvbox_underline = 0

" }}}

" FUNCTION {{{

function! ClearIndent(type)
    silent execute "normal! '[V']:left\r"
endfunction

function! YankToMemo(type, ...) range
    let sel_save = &selection
    let &selection = 'inclusive'
    let append_line = 0

    if a:type ==# 'line'
        normal! '[y']
    elseif a:type ==# 'char'
        let append_line = 1
        normal! `[v`]y
    elseif a:type ==# 'V'
        normal! gvy
    elseif a:type ==# 'v'
        let append_line = 1
        normal! gvy
    endif

    let win_to_return = winnr()
    wincmd l
    wincmd k
    normal! G

    if append_line
        call append('.', '')
        normal! j
    endif

    normal! p
    execute win_to_return . 'wincmd w'
    let &selection = sel_save
endfunction

function! JoinLines(type) range
    let reg_save = @@
    normal! '[d']
    let text = @@

    let lines = split(text, '\n')
    let char1 = nr2char(getchar())

    if char1 ==# '"' || char1 ==# "'"
        let i = 0
        while i < len(lines)
            let lines[i] = char1 . lines[i] . char1
            let i = i + 1
        endwhile
        let delim = nr2char(getchar()) . ' '
    else
        let delim = char1 . ' '
    endif

    let new_line = join(lines, delim)
    call setline('.', new_line)
    call append('.', '')
    let @@ = reg_save
endfunction

function! MarkListItems(type) range
    let reg_save = @@

    if a:type ==# 'V'
        normal! '<y'>
    elseif a:type ==# 'line'
        normal! '[V']y
    else
        finish
    endif

    let lines = split(@@, '\n')
    let indent = substitute(lines[0], '\v^(\s*)(\S.*)$', '\1', '')
    let order_style = 'stardash'
    let nr = getchar()
    let c = nr2char(nr)

    if c =~ '\v\d'
        let order_style = 'number'
        let n = c - 1
    elseif c =~# '[a-z]'
        let order_style = 'salpha'
        let n = nr - 1
    elseif c =~# '[A-Z]'
        let order_style = 'lalpha'
        let n = nr - 1
    elseif c ==# ' '
        let mark = ''
    elseif c ==# '['
        let mark = '- [ ] '
    else
        let mark = c . ' '
    endif

    let i = 0

    while i < len(lines)
        if lines[i] =~ '\v^' . indent . '\S' && lines[i] !~ '\v^\s*$'
            if order_style ==# 'number'
                let n = n + 1
                let mark = n . '. '
            elseif order_style =~# '\v^.alpha$'
                let n = n + 1
                let mark = nr2char(n) . '. '
            endif
            let lines[i] = substitute(lines[i], '\v^(\s*)(\d+\.\s|[a-zA-Z]\.\s|[*-]\s\[[.OoXx ]\]\s|[*-]\s)?(\S.*)', '\=submatch(1) . mark . submatch(3)', '')
        endif
        let i = i + 1
    endwhile

    let @@ = join(lines, "\n")
    silent! normal! gv"0p
    let @@ = reg_save
endfunction

function! SetHorizontalRule(lnum, level, len)
    let hr_chars  = [ '', '=', '-' ]

    if a:level < 1 || a:level > 2
        echoerr 'level must be a number between 1 and 2' 
        return
    endif

    if a:lnum > 0
        let hd_lnum = a:lnum
    else
        let hd_lnum = line('.')
    endif

    if a:len
        let hr_len  = a:len
    else
        let hd_line = getline(hd_lnum)
        let hr_len  = strwidth(hd_line)
    endif

    let hrule     = repeat(hr_chars[a:level], hr_len)
    let next_line = getline(hd_lnum + 1)

    if match(next_line, '\v^[-=]+$') >= 0
        call setline(hd_lnum + 1, hrule)
    else
        call append(hd_lnum, hrule)
    endif
endfunction

function! ToggleBackground()
    if &background ==# 'dark'
        set background=light
    else
        set background=dark
    endif
endfunction

function! ToggleColorColumn()
    if &colorcolumn == 80
        set colorcolumn=
    else
        set colorcolumn=80
    endif
endfunction

function! ToggleFTMode()
    if g:my_ftmode ==# 'kana'
        map f f
        map F F
        map t t
        map T T
        let g:my_ftmode = 'default'
        highlight! link CursorLine CursorColumn
    else
        noremap f f<C-K>
        noremap F F<C-K>
        noremap t t<C-K>
        noremap T T<C-K>
        let g:my_ftmode = 'kana'
        highlight! link CursorLine Error
    endif
endfunction

function! ChangeGruvboxContrast(val)
    let g:gruvbox_contrast_dark = a:val
    let g:gruvbox_contrast_light = a:val
    colorscheme gruvbox
endfunction

function! OpenRC(prog)
    if a:prog ==# 'vim'
        let path = '~/git/dotfiles/vim/dot-vimrc'
    elseif a:prog ==# 'bash'
        let path =  '~/git/dotfiles/bash/dot-bashrc'
    elseif a:prog ==# 'tmux'
        let path =  '~/git/dotfiles/tmux/dot-tmux.conf'
    elseif a:prog ==# 'xres'
        let path =  '~/git/dotfiles/X/dot-Xresources'
    else
        let path = '~/git/dotfiles/vim/dot-vimrc'
    endif
    silent! execute '$tabnew'
    silent! execute 'lcd ~/git/dotfiles'
    silent! execute 'e ' . path
endfunction

function! ArgReplace(pattern, substitute)
    cexpr []
    execute 'args `ag -l ' . a:pattern . '`'
    silent! execute 'argdo %s/\v' . a:pattern . '/'. a:substitute . '/g'
    silent! execute 'argdo vimgrepadd! /' . a:substitute  . '/gj %'
    copen
endfunction

function BufDoVim(pattern)
    cexpr []
    normal mA
    silent! execute 'bufdo vimgrepadd /\v' . a:pattern . '/gj %'
    normal 'A
    copen
endfunction

" vimcasts.org - show highlight group for the cword
function! <SID>SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" }}}

" COMMAND {{{

command! -nargs=1 -complete=file Rename file <args> | write | call delete(expand('#'))
command! -nargs=0 Cd lcd $HOME/Desktop

" }}}

" MAPPING {{{

" Basic {{{

nnoremap <Del> <nop>
nnoremap <Space> <nop>
let mapleader = "\<Space>"

" }}}
" Operator {{{

" delete into the blackhole register
nnoremap <Leader>d "_d

" clear indentation
nnoremap <Leader>< :set operatorfunc=ClearIndent<CR>g@
vnoremap <Leader>< :left<CR>

" yank to another buffer in the right
nnoremap <Leader>y :set operatorfunc=YankToMemo<CR>g@
vnoremap <Leader>y :call YankToMemo(visualmode(), 1)<CR>
nnoremap <Leader>yy 0:set operatorfunc=YankToMemo<CR>g@$

" join lines with delimiters
nmap <silent> <Plug>(JoinLines) :set operatorfunc=JoinLines<CR>g@
nmap <silent> <Leader>j <Plug>(JoinLines)
vnoremap <silent> <Leader>j :call JoinLines(visualmode())<CR>

" mark lines as list
nmap <silent> <Leader>l :set operatorfunc=MarkListItems<CR>g@ii
nmap <silent> <Leader>L :set operatorfunc=MarkListItems<CR>g@
vmap <silent> <Leader>l :call MarkListItems(visualmode())<CR>

" }}}
" Motion {{{

" map <Tab> %
nnoremap n nzzzv
nnoremap N Nzzzv

" for motion repeat with <Leader>.
nnoremap <Leader>m :normal<Space>

" }}}
" Text Object {{{

" custom pairs
let surroundings = ['<Bar>', '<Bslash>', ':', ',', '.', '/', ';', '_']
for s in surroundings
    execute printf("vnoremap i%s :<C-U>execute 'normal! T%svt%s'<CR>", s, s, s)
    execute printf("onoremap i%s :<C-U>execute 'normal! T%svt%s'<CR>", s, s, s)
    " treat char more like delimiter than surrounding
    execute printf("vnoremap a%s :<C-U>execute 'normal! F%svt%s'<CR>", s, s, s)
    execute printf("onoremap a%s :<C-U>execute 'normal! F%svt%s'<CR>", s, s, s)
endfor

" }}}
" Search {{{

nnoremap / /\v
nnoremap <Leader>h :nohlsearch<CR>

" substitution
nnoremap <Leader>/s :%s/\v//g<LEFT><LEFT><LEFT>
nnoremap <Leader>/S :%s/\v^//g<LEFT><LEFT><LEFT>
nnoremap <Leader>/r :argdo %s/\v//g<LEFT><LEFT><LEFT>
nnoremap <Leader>/R :argdo %s/\v//g <BAR> update

" grep
nnoremap <C-G> :execute 'silent grep! '<BAR>:redraw!<BAR>copen<C-LEFT>
nnoremap <Leader><C-G> :call BufDoVim('')<LEFT><LEFT>

" delete matched lines
nnoremap <Leader>/d :g/\v/d<LEFT><LEFT>
nnoremap <Leader>/D :g/\v^/d<LEFT><LEFT>
nnoremap <Leader>/v :v/\v/d<LEFT><LEFT>
nnoremap <Leader>/V :v/\v^/d<LEFT><LEFT>
vnoremap <Leader>/d :g/\v/d<LEFT><LEFT>
vnoremap <Leader>/D :g/\v^/d<LEFT><LEFT>
vnoremap <Leader>/v :v/\v/d<LEFT><LEFT>
vnoremap <Leader>/V :v/\v^/d<LEFT><LEFT>

" to jump from one URL/Email/Guid to another
nnoremap <Leader>/u /\v\chttps?:\/\/[^\s/$.?#].\s*[a-z0-9.~:/?#[\]@!$&'()*+,;=`._%-]+/<CR>
nnoremap <Leader>/U /\v<[a-zA-Z0-9.-]+\@[a-zA-Z0-9.-]+\.\w{2,3}>/<CR>
nnoremap <Leader>/g /\v<\c[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}><CR> 

" }}}
" Editing (Not Operator) {{{

" to avoid entering insert mode
nnoremap <Leader><CR> mzi<CR><Esc>`z
nnoremap <Leader><Space> i<Space><Esc>

" repeatable spell correction
nmap <Plug>CorrectNextSpellError ]s1z=:call repeat#set("\<Plug>CorrectNextSpellError")<CR>
nmap <Leader>s <Plug>CorrectNextSpellError
nmap <Plug>CorrectPrevSpellError [s1z=:call repeat#set("\<Plug>CorrectPrevSpellError")<CR>
nmap <Leader>S <Plug>CorrectPrevSpellError

" remove empty lines
nnoremap <silent> <Leader>e :silent! execute "%s/\u00a0//g"<CR>:silent! execute "normal! zR\r:g/^\\s*$/,/./-j\r:nohlsearch\r"<CR>
nnoremap <silent> <Leader>E :silent! execute "%s/\u00a0//g"<CR>:silent! execute "normal! :g/^\\s*$/d\r:nohlsearch\r"<CR>

" decorating
nnoremap <Leader>1 :call SetHorizontalRule(0, 1, 0)<CR>
nnoremap <Leader>2 :call SetHorizontalRule(0, 2, 0)<CR>

" quick join
nmap <Leader>,, <Plug>(JoinLines)ip,
nmap <Leader>,' <Plug>(JoinLines)ip',
nmap <Leader>," <Plug>(JoinLines)ip",

" }}}
" Fold {{{

nnoremap <Leader>z zMzvzz

" }}}
" Save, Close & Load {{{

inoremap <C-S> <C-O>:w<CR>
nnoremap <Leader>w :w<CR>
nnoremap <Leader>W :wq<CR>
nnoremap <Leader>q :q<CR>
nnoremap <Leader>Q :q!<CR>
nnoremap <silent> <Leader>r :silent! source %<CR>:nohlsearch<CR>

" }}}
" Window {{{

nnoremap <C-W>, :vnew<CR>
nnoremap <LEFT> <C-W><
nnoremap <RIGHT> <C-W>>
nnoremap <UP> <C-W>+
nnoremap <DOWN> <C-W>-

" }}}
" Tab Page {{{

nnoremap <C-W>N :$tabnew<CR>
nnoremap <C-W>% :$tabnew %<CR>
nnoremap <C-W>C :tabclose<CR>
nnoremap <C-W>V :call OpenRC('vim')<CR>
nnoremap <C-W>P :call OpenRC('bash')<CR>
nnoremap <C-W>R :call OpenRC('')<LEFT><LEFT>

" I don't miss default g0/g$ behavior
nnoremap g0 :1tabnext<CR>
nnoremap g$ :$tabnext<CR>

" }}}
" Toggle/Change Options and Stuff {{{

nnoremap <Esc>b :call ToggleBackground()<CR>
nnoremap <Esc>c :call ToggleColorColumn()<CR>
nnoremap <Esc>l :set list!<CR>
nnoremap <Esc>r :set relativenumber!<CR>
nnoremap <Esc>s :set spell!<CR>
nnoremap <Esc>f :call ToggleFTMode()<CR>
nnoremap <Esc>d :windo diffthis<CR>
nnoremap <Esc>D :windo diffoff<CR>
nnoremap <Esc>gs :call ChangeGruvboxContrast('soft')<CR>
nnoremap <Esc>gm :call ChangeGruvboxContrast('medium')<CR>
nnoremap <Esc>gh :call ChangeGruvboxContrast('hard')<CR>

" }}}
" Insert Mode {{{

" emacs-like
inoremap <C-B> <LEFT>
inoremap <C-F> <RIGHT>

" completion
inoremap <Tab> <C-X><C-O>
inoremap <C-L> <C-X><C-L>

" break undo
inoremap <C-W> <C-G>u<C-W>
inoremap <CR> <C-]><C-G>u<CR>

" IME
inoremap <ESC> <ESC>:set iminsert=0<CR>
inoremap <C-[> <ESC>:set iminsert=0<CR>
inoremap <C-G>i <ESC>:set iminsert=2<CR>a

" misc
inoremap <C-C> <C-R>=strftime("%Y-%m-%d %H:%M:%S")<CR>
inoremap <C-D> <C-R>=strftime("%Y-%m-%d")<CR>

" }}}
" Command-Line Mode {{{

nnoremap <Leader>; q:

" make command-line mode more like readline
cnoremap <C-A> <HOME>
cnoremap <C-B> <LEFT>
cnoremap <C-F> <RIGHT>
cnoremap <C-D> <DEL>
cnoremap <C-H> <BS>
cnoremap <C-Y> <C-R>"
cnoremap <ESC><C-F> <C-F>
cnoremap <ESC><C-D> <C-D>

" }}}
" Snippets {{{

nnoremap <silent> <Leader>'c :-1read $VIMRUNTIME/skelton/React_Component.txt<CR>/class<CR>:nohlsearch<CR>ela
nnoremap <silent> <Leader>'C :-1read $VIMRUNTIME/skelton/React_Component_State.txt<CR>/class<CR>:nohlsearch<CR>ela
nnoremap <silent> <Leader>'n :-1read $VIMRUNTIME/skelton/React_Component_Constructor.txt<CR>/state<CR>:nohlsearch<CR>o
nnoremap <silent> <Leader>'i :-1read $VIMRUNTIME/skelton/TS_Interface.txt<CR>/{<CR>:nohlsearch<CR>hi
nnoremap <silent> <Leader>'h :-1read $VIMRUNTIME/skelton/html5.txt<CR>/title<CR>:nohlsearch<CR>cit
nnoremap <silent> <Leader>'r :-1read $VIMRUNTIME/skelton/html5_React.txt<CR>/title<CR>:nohlsearch<CR>cit
nnoremap <silent> <Leader>'R :-1read $VIMRUNTIME/skelton/html5_React_Babel.txt<CR>/title<CR>:nohlsearch<CR>cit
nnoremap <silent> <Leader>'x :-1read $VIMRUNTIME/skelton/xhtml.txt<CR>/title<CR>:nohlsearch<CR>cit
nnoremap <silent> <Leader>'l :-1read $VIMRUNTIME/skelton/lorem.txt<CR>

" }}}
" Misc {{{

" help
nnoremap <Leader>H :vertical help<Space>

" repeat command
nnoremap <Leader>. @:
nnoremap <Leader>v :execute 'vertical ' . @:<CR>

" quickfix
nnoremap <C-N> :silent! cnext<CR>
nnoremap <C-P> :silent! cprevious<CR>
nnoremap <Leader>co :copen<CR>
nnoremap <Leader>cc :cclose<CR>

" dict
nnoremap K :call ShowWordDef(0)<CR>

" replay macro
nnoremap Q @q

" IME
nnoremap <ESC>i :set iminsert=0<CR>
cnoremap <ESC>i :set iminsert=0<CR>

" check highlight group of current word
nnoremap <Leader>ch :call <SID>SynStack()<CR>

" list mappings
nnoremap <Leader>cm :vnew<BAR>put=execute('map')<BAR>setf vim<BAR>sort<BAR>normal ggdip<CR>

" }}}

" }}}

" AUTOCMD {{{

" All Types {{{

augroup all_type
    autocmd!
    autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | execute "normal! g`\"" | endif
    autocmd VimResized * execute "normal! \<C-W>="
    " autocmd BufWritePost .vimrc source $MYVIMRC
augroup END

" }}}
" Bash {{{

augroup ft_sh
    autocmd!
    autocmd FileType sh let maplocalleader = "\<Space>"
    autocmd FileType sh nnoremap <buffer> <LocalLeader>,s :-1read $HOME/.vim/skelton/bash_script.txt<CR>G3
augroup END

" }}}
" PowerShell {{{

augroup ft_ps1
    autocmd!
    autocmd FileType ps1 let maplocalleader = "\<Space>"
    autocmd FileType ps1 setlocal fileformat=dos
    autocmd FileType ps1 setlocal foldmethod=syntax
    autocmd FileType ps1 setlocal iskeyword+=$
    autocmd FileType ps1 nnoremap <buffer> ]] :call search('\v\c^\s*function\s+\w', 'W')<CR>
    autocmd FileType ps1 nnoremap <buffer> [[ :call search('\v\c^\s*function\s+\w', 'bW')<CR>
    autocmd FileType ps1 nnoremap <buffer> ]p :call search('\v\c^\s*\[Parameter\(', 'W')<CR>
    autocmd FileType ps1 nnoremap <buffer> [p :call search('\v\c^\s*\[Parameter\(', 'bW')<CR>
    autocmd FileType ps1 nnoremap <buffer> <LocalLeader>'f :-read $VIMRUNTIME/skelton/ps/function.txt<CR>A<Space>
    autocmd FileType ps1 nnoremap <buffer> <LocalLeader>'F :-read $VIMRUNTIME/skelton/ps/advanced_function.txt<CR>A<Space>
    autocmd FileType ps1 nnoremap <buffer> <LocalLeader>'p :-read $VIMRUNTIME/skelton/ps/parameter.txt<CR>9jA
    autocmd FileType ps1 iabbrev <buffer> al [Alias('')]
    autocmd FileType ps1 iabbrev <buffer> aec [AllowEmptyCollection()]
    autocmd FileType ps1 iabbrev <buffer> aes [AllowEmptyString()]
    autocmd FileType ps1 iabbrev <buffer> an [AllowNull()]
    autocmd FileType ps1 iabbrev <buffer> po [PSCustomObject]
    autocmd FileType ps1 iabbrev <buffer> vc [ValidateCount()]<LEFT><LEFT>
    autocmd FileType ps1 iabbrev <buffer> vl [ValidateLength()]<LEFT><LEFT>
    autocmd FileType ps1 iabbrev <buffer> vn [ValidateNotNull()]
    autocmd FileType ps1 iabbrev <buffer> vne [ValidateNotNullOrEmpty()]
    autocmd FileType ps1 iabbrev <buffer> vp [ValidatePattern('')]<LEFT><LEFT><LEFT>
    autocmd FileType ps1 iabbrev <buffer> vr [ValidateRange()]<LEFT><LEFT>
    autocmd FileType ps1 iabbrev <buffer> vs [ValidateSet()]<LEFT><LEFT>
    autocmd FileType ps1 iabbrev <buffer> vsc [ValidateScript({})]<LEFT><LEFT><LEFT>
    autocmd FileType ps1 syntax match ParamStart '\v^\s*\[[a-zA-Z]+\('
    autocmd FileType ps1 highlight link ParamStart PreProc
    autocmd FileType ps1 syntax match ParamEnd '\v\)\]'
    autocmd FileType ps1 highlight link ParamEnd PreProc
augroup END

function! PoshFolds()
    let thisline = getline(v:lnum)
    if thisline =~? '\v^\s*function\s+\w'
        return '>1'
    elseif thisline =~? '\v^\s*}'
        let lnum_with_pair = searchpair('{', '', '}', 'bnW', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
        if getline(lnum_with_pair) =~? '\v^\s*function\s+\w'
            return '<1'
        endif
    else
        return '='
    endif
endfunction

" }}}
" PowerShell Help {{{

augroup ft_ps1help
    autocmd!
    autocmd FileType ps1help let maplocalleader = "\<Space>"
    autocmd FileType ps1help setlocal buftype=nofile
    autocmd FileType ps1help setlocal fileformat=dos
    autocmd FileType ps1help setlocal foldmethod=expr
    autocmd FileType ps1help setlocal foldexpr=PoshHelpFolds()
    autocmd FileType ps1help setlocal iskeyword+=$
    autocmd FileType ps1help syntax match PSHLevel1FoldHeading '\v^(NAME|SYNOPSIS|SYNTAX|PARAMETERS|INPUTS|OUTPUTS|ALIASES|REMARKS|NOTES|DESCRIPTION|LINK|RELATED\sLINKS)$'
    autocmd FileType ps1help highlight link PSHLevel1FoldHeading Directory
    autocmd FileType ps1help syntax match PSHLevel2FoldHeading '\v^\s{4}(-[a-zA-Z].+\s\[?\<[a-zA-Z0-9]+\>\]?|\<CommonParameters\>)$'
    autocmd FileType ps1help highlight link PSHLevel2FoldHeading MoreMsg
    autocmd FileType ps1help syntax match PSHExample '\v^\s+-+\sEXAMPLE\s\d+\s-+$'
    autocmd FileType ps1help highlight link PSHExample Question
    autocmd FileType ps1help syntax match PSHExamplePrompt '\v^\s{4}PS\sC:\\\>'
    autocmd FileType ps1help highlight link PSHExamplePrompt MoreMsg
    autocmd FileType ps1help syntax match PSHOptionalParam '\v\[?\[-[a-zA-Z]\w+\]?(\s\<[a-zA-Z0-9]+\>|\s\{[^}]+\})?\]'
    autocmd FileType ps1help syntax match PSHOptionalParam '\v\[-[a-zA-Z]\w+\s*$'
    autocmd FileType ps1help syntax match PSHOptionalParam '\v\<[a-zA-Z0-9]+(\[\])?\>\]'
    autocmd FileType ps1help syntax match PSHOptionalParam '\v\[\<CommonParameters\>\]'
    autocmd FileType ps1help highlight link PSHOptionalParam Comment
    autocmd FileType ps1help syntax match PSHHighlighted '\v^\s{8}Default\svalue\s+\zs.+$'
    autocmd FileType ps1help syntax match PSHHighlighted '\v^\s{8}Accept\spipeline\sinput\?\s+\zstrue$'
    autocmd FileType ps1help highlight link PSHHighlighted Statement
    autocmd FileType ps1help execute "normal \<F11>"
    autocmd FileType ps1help execute "normal zR"
augroup END

function! PoshHelpFolds()
    let thisline = getline(v:lnum)
    if thisline =~? '\v^(NAME|SYNOPSIS|SYNTAX|PARAMETERS|INPUTS|OUTPUTS|ALIASES|REMARKS|NOTES|DESCRIPTION|LINK|RELATED\sLINKS)$'
        return '>1'
    elseif thisline =~? '\v^\s+-+\sEXAMPLE\s\d+\s-+$'
        return '>1'
    elseif thisline =~? '\v^\s{4}(-[a-zA-Z].+\s\[?\<[a-zA-Z0-9]+\>\]?|\<CommonParameters\>)$'
        return '>2'
    else
        return '='
    endif
endfunction

" }}}

" }}}

" DICTIONARY {{{

function! ShowWordDef(vertical)
    let cword       = expand('<cword>')
    let back_to_cmd = 0
    let dict_cmd    = 'sdcv'

    let winnr = bufwinnr('__WordDef__')
    if winnr > 0
        execute winnr . 'wincmd w'
    else
        if a:vertical
            vsplit __WordDef__
        else
            20split __WordDef__
        endif
    endif

    setlocal filetype=wdef
    setlocal buftype=nofile

    normal! ggdG
    silent! execute '-1read !' . dict_cmd . ' ' . cword

    let wordclass = 'noun|pronoun|adjective|verb|adverb|preposition|conjunction|interjection'
    " see also + more at: prefix with >, put line breaks before & after
    silent! execute '%s/\v^(see\salso\s.*|more\sat\s.*)$/\r  > \1\r/'
    " split examples, that start with star
    silent! execute '%s/\v\s\*\s/\r/g'
    "example lines: prefix with -, indent
    silent! execute '%s/\v^([a-zA-Z0-9[(].*[^:])\s*$/  - \1'
    " word class: prefix with =, separate definition part, put line breaks before & after
    silent! execute '%s/\v\c^\s{4}(' . wordclass . ')\s*(.*)$/\r[\U\1]\E\r\r\2\r/'
    " category line: prefix with #, put line breaks before & after
    silent! execute '%s/\v^\s{2}([a-zA-Z].*[^:])\s*$/\r# \1\r/'
    " definition line: decorate number in the beginning
    silent! execute '%s/\v^\s*(\d+)\s*(.*\s+.*:)\s*$/\1. \2/'
    " definition line: putline breaks before & after, clear indent
    silent! execute '%s/\v^\s*(.*\s+.*:)\s*$/\r\1\r/'
    " sub section heading: enclose with bar, put line breaks before & after, clear indent
    silent! execute '%s/\v^\s{1}([A-Z].*[A-Z])\s*$/\r|\1|\r/'
    " remove unwanted beginning lines
    silent! execute '1,5d'
    " join multiple blank lines into one
    silent! execute 'normal! :g/\v^\s*$/,/\S/-j' . "\r" . ':nohlsearch' . "\r"

    normal! gg

endfunction

augroup ft_wdef
    autocmd!
    autocmd FileType wdef syntax match WDefGroup '\v^#\s.*'
    autocmd FileType wdef highlight link WDefGroup Title
    autocmd FileType wdef syntax match WDefDef '\v^.*:\s*$'
    autocmd FileType wdef highlight link WDefDef MoreMsg
    autocmd FileType wdef syntax match WDefSubsect '\v^\|.*$'
    autocmd FileType wdef highlight link WDefSubsect Conceal
    autocmd FileType wdef syntax match WDefClass '\v^\[.*\s*$'
    autocmd FileType wdef highlight link WDefClass Macro
    autocmd FileType wdef syntax match WDefAdditional '\v^\s*\>.*$'
    autocmd FileType wdef highlight link WDefAdditional Comment
augroup END

" man

let $GROFF_NO_SGR=1
source $VIMRUNTIME/ftplugin/man.vim

" }}}

" Markdown {{{

augroup ft_markdown
    autocmd!
    autocmd FileType markdown,vimwiki let maplocalleader = "\<Space>"
    autocmd FileType markdown,vimwiki highlight def VimwikiHeaderChar guibg=bg guifg=#fe8019 gui=bold ctermbg=bg ctermfg=208 term=bold
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>gc I<!-- <Esc>A --><Esc>
    autocmd FileType markdown,vimwiki vnoremap <buffer> <LocalLeader>gc :normal! I<--! <Esc>gv:normal! A --><Esc>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>0 :s/\v^#+\s*//<CR>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>1 I# <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>2 I## <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>3 I### <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>4 I#### <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>5 I##### <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>6 I###### <C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>bb {o```<C-[>}O```<C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>bv {o```vim<C-[>}O```<C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>bp {o```powershell<C-[>}O```<C-[>
    autocmd FileType markdown,vimwiki nnoremap <buffer> <LocalLeader>bP {o```python<C-[>}O```<C-[>
augroup END

" }}}

" MS WINDOWS {{{

if has('win32')
    " options
    set fileformat=unix
    set fileformats=unix,dos
    set fencs=utf-8,ucs-bom,iso-2022-jp,euc-jp,cp932,utf-16le,utf-16,default
    set encoding=utf-8  " The encoding displayed.
    set fileencoding=utf-8  " The encoding written to file.
    set ambiwidth=double
    set clipboard=unnamed

    " mappings
    nnoremap <Leader>cm :SwitchToCmd<CR>
    nnoremap <Leader>ps :SwitchToPosh<CR>
    nnoremap <Leader>pm :OpenPSMod<Space>

    " commands
    command! SwitchToCmd call SetWinShell('cmd')
    command! SwitchToPosh call SetWinShell('posh')
    command! -nargs=1 -complete=customlist,ListMyPSModules OpenPSMod call OpenPSModule(<q-args>)

    if !exists('g:airline_symbols')
        let g:airline_symbols = {}
    endif
    let g:airline_symbols.crypt = '🔒'
    let g:airline_symbols.paste = 'ρ'
    let g:airline_symbols.paste = 'Þ'
    let g:airline_symbols.paste = '∥'
    let g:airline_symbols.notexists = '∄'
    let g:airline_symbols.whitespace = 'Ξ'
    let g:airline_symbols.branch = ''
    let g:airline_symbols.readonly = ''
    let g:airline_left_sep = ''
    let g:airline_left_alt_sep = ''
    let g:airline_right_sep = ''
    let g:airline_right_alt_sep = ''

    " functions
    function! ListMyPSModules(A, L, P)
        let my_ps_mod_dir = "$USERPROFILE\\Documents\\WindowsPowerShell\\MyModules"
        let prefix = a:A . '*'
        let mod_full_paths = split(globpath(my_ps_mod_dir, prefix), '\n')
        let mod_names = []
        for p in mod_full_paths
            let segments = split(p, '\')
            let basename = segments[-1]
            let mod_names += [ basename ]
        endfor
        return mod_names
    endfunction

    function! SetWinShell(shell)
        if a:shell ==# 'posh'
            set shell=powershell
            set shellcmdflag=-ExecutionPolicy\ RemoteSigned
        elseif a:shell ==# 'cmd'
            set shell=C:\\WINDOWS\\system32\\cmd.exe
            set shellcmdflag=/c
        endif
    endfunction

    function! OpenPSModule(ps_module)
        let dir = '$USERPROFILE\\Documents\\WindowsPowerShell\\MyModules\\' . a:ps_module
        let ps1s = split(globpath(dir, '**/*.ps1'), '\n')
        for p in ps1s
            silent! execute 'argadd ' . p
        endfor
        silent! execute 'lcd ' . dir
        silent! execute 'e ' . a:ps_module . '.psd1'
    endfunction

    if has('gui_running')
        let cwd = getcwd()
        if cwd ==# 'C:\Windows\System32'
            cd ~/Desktop
        endif

        set mouse=
        set guioptions-=a
        set guioptions-=i
        set guioptions-=m
        set guioptions-=t
        set guioptions-=T
        set guioptions-=r
        set guioptions-=R
        set guioptions-=l
        set guioptions-=L
        set guioptions-=b
        set guioptions-=h
        set guioptions-=v
        set guioptions-=p
        set guioptions-=F
        set guioptions-=e    " don't show gui tabline!
        nmap <F11> :call libcallnr('gvimfullscreen.dll', 'ToggleFullScreen', 0)<CR>
        imap <F11> <ESC>:call libcallnr('gvimfullscreen.dll', 'ToggleFullScreen', 0)<CR>a
        nmap <silent> <Leader>r :silent! source %<CR>:nohlsearch<CR><F11><F11>
        nmap <C-W>P :$tabnew $HOME/Documents/WindowsPowerShell/profile.ps1<CR><F11><F11>
        nmap <C-Up> :call ChangeGUIFontSize(0)<CR><F11><F11>
        nmap <C-Down> :call ChangeGUIFontSize(1)<CR><F11><F11>

        set linespace=2
        set guifont=Consolas\ NF:h13
        set guifontwide=mplus\ NF:h12

        function! ChangeGUIFontSize(decrease)
            let parts    = split(&guifont, ':')
            let facename = parts[0]
            let fontsize = substitute(parts[1], 'h', '', '')

            if a:decrease
                let fontsize -= 1
            else
                let fontsize += 1
            endif

            let &guifont = printf('%s:h%d', facename, fontsize)
        endfunction
    else
        " syntax off
        syntax off
        set t_Co=256
        set term=xterm

        " workaround for conemu's bug
        inoremap <C-H> <BS>
        inoremap <Char-0x07F> <BS>
        nnoremap <Char-0x07F> <BS>
    endif
endif

" }}}

" TESTING {{{

" highlight
nnoremap <Leader>/0 :call clearmatches()<CR>
nnoremap <Leader>/1 :match DiffAdd /\v/<LEFT>
nnoremap <Leader>/2 :2match Error /\v/<LEFT>
nnoremap <Leader>/3 :3match PmenuSel /\v/<LEFT>
nnoremap <Leader>/4 :call matchadd('DiffAdd', '\v')<LEFT><LEFT>
nnoremap <Leader>/w :call matchadd('DiffAdd', expand('<cword>'))<CR>
nnoremap <Leader>/W :call matchadd('DiffAdd', expand('<cWORD>'))<CR>

" moving visual block up/down
vnoremap <C-J> :m '>+1<CR>gv=gv
vnoremap <C-K> :m '<-2<CR>gv=gv

if has('multi_byte_ime')
    highlight link CursorIM Error
endif

" tmp
nnoremap <silent> <Leader>'p :-1read $VIMRUNTIME/skelton/TMP_GetPPCode.txt<CR>
nnoremap <silent> <Leader>'v :-1read $VIMRUNTIME/skelton/TMP_UPV_Constructor.txt<CR>
nnoremap <silent> <Leader>'m :-1read $VIMRUNTIME/skelton/TMP_TS_IMPORT.txt<CR>/{<CR>:nohlsearch<CR>la

" }}}
